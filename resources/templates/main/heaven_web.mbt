// DON'T EDIT THIS FILE. IT IS GENERATED BY THE HEAVEN PACKAGE.
pub struct Receiver {
  buffer : Buffer
  listener_map : Map[String, (String) -> Unit]
}

pub fn h_ss() = "__h" "h_ss"

pub fn h_sd(data : Int) = "__h" "h_sd"

pub fn h_se() = "__h" "h_se"

let receiver : Receiver = { buffer: Buffer::new(), listener_map: Map::new() }

pub fn h_rs() -> Unit {
  receiver.buffer.reset()
}

pub fn h_rd(data : Int) -> Unit {
  if data != 0 {
    receiver.buffer.write_char(Char::from_int(data))
  }
}

pub fn h_re() -> Unit {
  let message = receiver.buffer.to_string()
  match @json.parse(message)!! {
    Ok(
      Object(
        { "type": Some(String(event_type)), "data": Some(String(event_data)) }
      )
    ) =>
      match receiver.listener_map[event_type] {
        Some(listener) => listener(event_data)
        None => println("No listener for event type: " + event_type)
      }
    Ok(json) => println("type and data not found in \(json)")
    Err(e) => println("Error parsing JSON: \(e)")
  }
}

pub fn listen_event(event_type : String, callback : (String) -> Unit) -> Unit {
  receiver.listener_map[event_type] = callback
}

/// Evaluate a string as JavaScript code. (Don't use this in production code)
pub fn eval(str : String) -> Unit {
  // println("{ \"type\": \"eval\", \"data\": \"" + str + "\" }")
  send_event("eval", str)
}

fn transform_string(s : String) -> String {
  return s.replace_all(old="\n", new="\\n").replace_all(old="\"", new="\\\"")
}

fn send_event(event_type : String, event_data : String) -> Unit {
  let body = "{ \"type\": \"" + event_type + "\", \"data\": \"" + transform_string(
      event_data,
    ) + "\" }"
  let chars = body.to_array().map(fn(c) { c.to_int() })
  h_ss()
  chars.each(fn(c) { h_sd(c) })
  h_se()
}
