// DON'T EDIT THIS FILE. IT IS GENERATED BY THE HEAVEN PACKAGE.
pub struct Receiver {
  buffer : Buffer
  listener_map : Map[String, (String) -> Unit]
}

pub fn h_ss() = "__h" "h_ss"

pub fn h_sd(data : Int) = "__h" "h_sd"

pub fn h_se() = "__h" "h_se"

let receiver : Receiver = { buffer: Buffer::new(), listener_map: Map::new() }

pub fn h_rs() -> Unit {
  receiver.buffer.reset()
}

pub fn h_rd(data : Int) -> Unit {
  if data != 0 {
    receiver.buffer.write_char(Char::from_int(data))
  }
}

pub fn h_re() -> Unit {
  let message = receiver.buffer.to_string()
  println("Received message: " + message)
  let json = (match @json.parse(message)!! {
    Ok(json) => json
    Err(error) => {
      console_log(message + " " + error.to_string())
      return
    }
  }).as_object()
  match json {
    Some(json) => {
      let event_type = json["type"].or(@json.JsonValue::Null).as_string().or("")
      let event_data = json["data"].or(@json.JsonValue::Null).as_string().or("")
      let listener = receiver.listener_map[event_type]
      match listener {
        Some(listener) => listener(event_data)
        None => console_log("No listener for event type: " + event_type)
      }
    }
    None => {
      console_log("Error parsing JSON")
      return
    }
  }
}

pub fn listen_event(event_type : String, callback : (String) -> Unit) -> Unit {
  receiver.listener_map[event_type] = callback
}

/// Evaluate a string as JavaScript code. (Don't use this in production code)
pub fn eval(str : String) -> Unit {
  // println("{ \"type\": \"eval\", \"data\": \"" + str + "\" }")
  send_event("eval", str)
}

fn transform_string(s : String) -> String {
  return s.replace_all(old="\n", new="\\n").replace_all(old="\"", new="\\\"")
}

fn console_log(message : String) -> Unit {
  send_event("log", message)
}

fn send_event(event_type : String, event_data : String) -> Unit {
  let body = "{ \"type\": \"" + event_type + "\", \"data\": \"" + transform_string(
      event_data,
    ) + "\" }"
  let chars = body.to_array().map(fn(c) { c.to_int() })
  h_ss()
  chars.each(fn(c) { h_sd(c) })
  h_se()
}
